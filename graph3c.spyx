"""

flagmatic 2

Copyright (c) 2012, E. R. Vaughan. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1) Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2) Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

#clang c

#
# TODO: enforce number of vertices <= 7.
#  More sanity checking.
#
#
#

from libc.stdlib cimport malloc, calloc, free
from libc.string cimport memset

DEF MAX_NUMBER_OF_EDGES = 35


# TODO: check that flag contains type

cdef class flagmatic_flag:

	cdef int _n
	cdef readonly int ne
	cdef int _edges[MAX_NUMBER_OF_EDGES * 3]
	cdef public flagmatic_flag type


	def __init__(self, string_rep=None, tg=None):
	
		if tg:
			self.type = <flagmatic_flag?> tg
	
		if string_rep:
			self.init_from_string(string_rep)

	property edges:

		def __get__(self):
	
			cdef int i
			edge_list = []
			for i in range(0, 3 * self.ne, 3):
				edge_list.append((self._edges[i], self._edges[i + 1], self._edges[i + 2]))
			return tuple(edge_list)


	property n:

		def __get__(self):
			return self._n
	
		def __set__(self, value):
			if value < self._n or value > 7:
				raise ValueError
			self._n = value


	def add_edge(self, edge):
	
		cdef int i, x
		for i in range(3):
			x = <int?> edge[i]
			if x < 1 or x > self._n:
				raise ValueError
			self._edges[3 * self.ne + i] = x
		self.ne += 1
		

	def __getitem__(self, name):
	
		cdef int i = <int?> name
		if i < self.ne:
			return (self._edges[3 * i], self._edges[3 * i + 1], self._edges[3 * i + 2])
		else:
			raise IndexError


	def __iter__(self):
	
		return list(self.edges).__iter__()
	
		
	def init_from_string(self, s):

		cdef int i, n, ne, x

		if s[1] != ":":
			raise ValueError

		n = int(s[0])
		if n < 0 or n > 7:
			raise ValueError
		self._n = n
		
		ne = len(s) - 2
		if ne % 3 != 0:
			raise ValueError
		ne /= 3
		self.ne = ne
		
		for i in range(3 * ne):
			x = int(s[i + 2]) # N.B. +2 because of n: header
			if x < 1 or x > n:
				raise ValueError
			self._edges[i] = x


	def __str__(self):

		cdef int i
		string_rep = str(self._n) + ":"
		for i in range(3 * self.ne):
			string_rep += str(self._edges[i])
		return string_rep

 	
	def __repr__(self):
		return self.__str__()


	# TODO: do this the Cythonic way (__richcmp__ ?)
	
	def is_equal(self, flagmatic_flag other):
	
		cdef int i

		if self._n != other._n:
			return False

		if self.ne != other.ne:
			return False

		#if not self.type.is_equal(other.type):
		#	return False
		
		for i in range(3 * self.ne):
			if self._edges[i] != other._edges[i]:
				return False
	
		return True


	# TODO: work out how to make sets of these work
	
	def __hash__(self):
	
		if self.type is None:
			return hash(self.__str__())
		else:
			return hash(self.__str__() + self.type.__str__())
		

	def copy(self):
	
		return flagmatic_flag(self.__str__(), tg=self.type)


	def degrees(self):

		cdef int i
		deg_list = [0 for i in range(self._n)]
		for i in range(3 * self.ne):
			deg_list[self._edges[i] - 1] += 1
		return tuple(deg_list)

	
	def edge_density(self):
		"""
		Returns the edge density, i.e. the number of edges divided by binomial(n, 3),
		where n is the number of vertices.
		"""
		return self.ne / binomial(self._n, 3)


	def subgraph_density(self, h):
		"""
		Returns the H-density. That is, the number of k-sets of vertices that induce
		graphs isomorphic to H, divided by binomial(n, k).
		"""
		
		found, total = 0, 0
		minh = h.copy()
		minh.make_minimal_isomorph()
		
		for hv in Combinations(range(1, self._n + 1), h._n):
			ig = self.induced_subgraph(hv)
			ig.make_minimal_isomorph()
			if minh == ig:
				found += 1
			total += 1
	
		return Integer(found) / total


	def relabel(self, verts):

		cdef int i
	
		if len(verts) != self._n:
			raise ValueError
	
		for i in range(len(verts)):
			if verts[i] < 1 or verts[i] > self._n:
				raise ValueError
	
		for i in range(3 * self.ne):
			self._edges[i] = verts[self._edges[i] - 1]

		self.minimize_edges()

	
	def minimize_edges(self):
	
		raw_minimize_edges(self._edges, self.ne)


	def make_minimal_isomorph(self):

		cdef int i, t, *new_edges, *winning_edges, *e
		cdef int *p, np, is_lower
		
		new_edges = <int *> malloc (sizeof(int) * 3 * self.ne)
		winning_edges = <int *> malloc (sizeof(int) * 3 * self.ne)
		
		if self.type is None:
			t = 0
		else:
			t = self.type._n
		
		p = generate_permutations_fixing(self._n, t, &np)
	
		for i in range(np):
		
			for j in range(3 * self.ne):
				new_edges[j] = p[self._n * i + self._edges[j] - 1]
		
			raw_minimize_edges(new_edges, self.ne)
	
			if i == 0:
				for j in range(3 * self.ne):
					winning_edges[j] = new_edges[j]
				continue
	
			is_lower = 1
	
			for j in range(3 * self.ne):
				if new_edges[j] > winning_edges[j]:
					is_lower = 0
					break
				elif new_edges[j] < winning_edges[j]:
					break
			
			if is_lower: # We have a new winner
				for j in range(3 * self.ne):
					winning_edges[j] = new_edges[j]
		
		for i in range(3 * self.ne):
			self._edges[i] = winning_edges[i]
		
		free(new_edges)
		free(winning_edges)


	def induced_subgraph(self, verts):
	
		cdef int i, *c_verts, num_verts
		cdef flagmatic_flag ig
		
		num_verts = len(verts)
		c_verts = <int *> malloc(num_verts * sizeof(int))
		
		for i in range(num_verts):
			c_verts[i] = <int ?> verts[i]
		
		ig = self.c_induced_subgraph(c_verts, num_verts)
		return ig


	cdef flagmatic_flag c_induced_subgraph(self, int *verts, int num_verts):

		cdef int nm = 0, i, j, *e, got, te[3]
		cdef flagmatic_flag ig = flagmatic_flag()
		ig.n = num_verts
		ig.type = None
		
		for i in range(self.ne):
			e = &self._edges[3 * i]
			got = 0
			for j in range(num_verts):
				if e[0] == verts[j]:
					got += 1
					te[0] = j + 1
				elif e[1] == verts[j]:
					got += 1
					te[1] = j + 1
				elif e[2] == verts[j]:
					got += 1
					te[2] = j + 1
			if got == 3:
				e = &ig._edges[3 * nm]
				e[0] = te[0]
				e[1] = te[1]
				e[2] = te[2]
				nm += 1
		ig.ne = nm
		ig.minimize_edges()

		return ig
	

	cdef int c_has_subgraph (self, flagmatic_flag h):
	
		cdef int i, j, k, l, *p, np, *new_edges, got_all, got_edge, got
	
		new_edges = <int *> malloc (sizeof(int) * 3 * self.ne)
		
		p = generate_permutations(self._n, &np)
	
		for i in range(np):
		
			for j in range(3 * self.ne):
				new_edges[j] = p[self._n * i + self._edges[j] - 1]
	
			got_all = 1
			for j in range(h.ne):
				got_edge = 0
				for k in range(self.ne):
					got = 0
					for l in range(3):
						if (h._edges[3 * j] == new_edges[(3 * k) + l] or 
							h._edges[(3 * j) + 1] == new_edges[(3 * k) + l] or
							h._edges[(3 * j) + 2] == new_edges[(3 * k) + l]):
							got += 1
					if got == 3:
						got_edge = 1
						break
				if got_edge == 0:
					got_all = 0
					break
		
			if got_all:
				free(new_edges)
				return 1
	
		free(new_edges)
		return 0

	
	def has_forbidden_edge_numbers(self, forbidden_edge_numbers, must_have_highest=False):
	
		cdef int *c, nc, i, j, k, l, fe, *edges, *e, got, *comb, num_e
	
		for pk, pfe in forbidden_edge_numbers.iteritems():
	
			k = <int ?> pk
			fe = <int ?> pfe
			
			if k > self._n:
				continue # vacuous condition
	
			if fe < 1:
				raise ValueError
			
			if must_have_highest:
			
				c = generate_combinations(self._n - 1, k - 1, &nc)
	
				for i in range(nc):
					comb = &c[(k - 1) * i]
					num_e = 0
					for j in range(self.ne):
						got = 0
						e = &self._edges[3 * j]
						for l in range(k - 1):
							if comb[l] == e[0] or comb[l] == e[1] or comb[l] == e[2]:
								got += 1
						if self._n == e[0] or self._n == e[1] or self._n == e[2]:
								got += 1
						if got == 3:
							num_e += 1
							if num_e == fe:
								return True
	
			else:
	
				c = generate_combinations(self._n, k, &nc)
	
				for i in range(nc):
					comb = &c[k * i]
					num_e = 0
					for j in range(self.ne):
						got = 0
						e = &self._edges[3 * j]
						for l in range(k):
							if comb[l] == e[0] or comb[l] == e[1] or comb[l] == e[2]:
								got += 1
						if got == 3:
							num_e += 1
							if num_e == fe:
								return True
	
		return False


	def has_forbidden_graphs(self, graphs, must_have_highest=False, induced=False):
	
		cdef int *c, nc, i, j, k, cne, *cur_edges, *e
		cdef flagmatic_flag h, ig
		
		cur_edges = <int *> malloc (sizeof(int) * 3 * self.ne)
		
		for i in range(len(graphs)):
	
			h = <flagmatic_flag ?> graphs[i]
	
			if h._n > self._n:
				continue # vacuous condition
	
			if must_have_highest:
				c = generate_combinations_plus(self._n, h._n, &nc)
			else:
				c = generate_combinations(self._n, h._n, &nc)
	
			for j in range(nc):
			
				ig = self.c_induced_subgraph(&c[j * h._n], h._n)
			
				if ig.ne < h.ne:
					continue
					
				if induced and ig.ne > h.ne:
					continue
				
				if ig.c_has_subgraph(h):
					free(cur_edges)
					return True
	
		free(cur_edges)
		return False



ctypedef struct raw_graph:
	int n, ne
	int edges[MAX_NUMBER_OF_EDGES * 3]

cdef class graph_block:
	cdef int n, len
	cdef raw_graph *graphs

def make_graph_block(graphs, n):

	cdef int i, j, ne, *e
	gb = graph_block()
	gb.n = n
	gb.len = len(graphs)

	gb.graphs = <raw_graph *> calloc (gb.len, sizeof(raw_graph))
	
	for i in range(gb.len):
		g = graphs[i]
		ne = len(g[1])
		gb.graphs[i].n = g[0]
		gb.graphs[i].ne = ne
		for j in range(ne):
			e = &(gb.graphs[i].edges[3 * j])
			e[0] = g[1][j][0]
			e[1] = g[1][j][1]
			e[2] = g[1][j][2]
	
	return gb


cdef class combinatorial_info_block:
	cdef int np
	cdef int *p


previous_permutations = {}

cdef int *generate_permutations_fixing(int n, int s, int *number_of):

	cdef int *p, fac, i, j

	# see if we've already generated it!
	key = (n, s)
	if key in previous_permutations.iterkeys():
	
		cib = <combinatorial_info_block>previous_permutations[key]
		fac = cib.np
		p = cib.p
	
	else:

		perms = Permutations(range(s + 1, n + 1)).list()
		fac = len(perms)
		p = <int *> malloc (sizeof(int) * n * fac)
		for i in range(fac):
			for j in range(n):
				if j < s:
					p[(i * n) + j] = j + 1
				else:
					p[(i * n) + j] = <int> perms[i][j - s]

		cib = combinatorial_info_block()
		cib.np = fac
		cib.p = p
		previous_permutations[key] = cib
	
	if number_of:
		number_of[0] = fac

	return p

cdef int *generate_permutations(int n, int *number_of):

	return generate_permutations_fixing(n, <int> 0, number_of)

def get_permutations (n):
 
	cdef int *p, np, i, j
	p = generate_permutations(n, &np)
	return [[p[(i * n) + j] for j in range(n)] for i in range(np)]


previous_combinations = {}

cdef int *generate_combinations(int n, int s, int *number_of):

	cdef int *p, fac, i, j

	# see if we've already generated it!
	key = (n, s)
	if key in previous_combinations.iterkeys():
	
		cib = <combinatorial_info_block>previous_combinations[key]
		fac = cib.np
		p = cib.p

	else:

		perms = Combinations(range(1, n + 1), s).list()
		fac = len(perms)
		p = <int *> malloc (sizeof(int) * s * fac)
		for i in range(fac):
			for j in range(s):
				p[(i * s) + j] = <int> perms[i][j]

		cib = combinatorial_info_block()
		cib.np = fac
		cib.p = p
		previous_combinations[key] = cib
	
	if number_of:
		number_of[0] = fac

	return p

def get_combinations (n, s):

	cdef int *p, np, i, j
	p = generate_combinations(n, s, &np)
	return [[p[(i * s) + j] for j in range(s)] for i in range(np)]


# Combinations that always contain maximum element
previous_combinations_plus = {}

cdef int *generate_combinations_plus(int n, int s, int *number_of):

	cdef int *p, fac, i, j

	# see if we've already generated it!
	key = (n, s)
	if key in previous_combinations_plus.iterkeys():
	
		cib = <combinatorial_info_block>previous_combinations_plus[key]
		fac = cib.np
		p = cib.p

	else:

		perms = Combinations(range(1, n), s - 1).list()
		fac = len(perms)
		p = <int *> malloc (sizeof(int) * s * fac)
		for i in range(fac):
			for j in range(s - 1):
				p[(i * s) + j] = <int> perms[i][j]
			p[(i * s) + s - 1] = n

		cib = combinatorial_info_block()
		cib.np = fac
		cib.p = p
		previous_combinations_plus[key] = cib
	
	if number_of:
		number_of[0] = fac

	return p


def get_combinations_plus (n, s):

	cdef int *p, np, i, j
	p = generate_combinations_plus(n, s, &np)
	return [[p[(i * s) + j] for j in range(s)] for i in range(np)]


previous_pair_combinations = {}

cdef int *generate_pair_combinations(int n, int s, int m1, int m2, int *number_of):

	cdef int *p, fac, i, j

	# see if we've already generated it!
	key = (n, s, m1, m2)
	if key in previous_pair_combinations.iterkeys():
	
		cib = <combinatorial_info_block>previous_pair_combinations[key]
		fac = cib.np
		p = cib.p
	
	else:
	
		fac = falling_factorial(n, s) * binomial(n - s, m1 - s) * binomial(n - m1, m2 - s)
		p = <int *> malloc (sizeof(int) * n * fac)
		i = 0
		vertices = range(1, n + 1)
		perms = Permutations(vertices, s)
		for perm in perms:
			available_verts = [v for v in vertices if not v in perm]
			combs1 = Combinations(available_verts, m1 - s)
			first_one = True
			for comb1 in combs1:
				remaining_verts = [v for v in available_verts if not v in comb1]
				combs2 = Combinations(remaining_verts, m2 - s)
				first_two = True
				for comb2 in combs2:
					for j in range(s):
						if first_one:
							p[(i * n) + j] = <int> perm[j]
						else:
							p[(i * n) + j] = <int> 0
					for j in range(m1 - s):
						if first_two:
							p[(i * n) + s + j] = <int> comb1[j]
						else:
							p[(i * n) + s + j] = <int> 0
					for j in range(m2 - s):
						p[(i * n) + m1 + j] = <int> comb2[j]
					for j in range(n - m1 - m2 + s):
						p[(i * n) + m1 + m2 - s + j] = <int> 0
					first_one = False
					first_two = False
					i += 1			

		cib = combinatorial_info_block()
		cib.np = fac
		cib.p = p
		previous_pair_combinations[key] = cib
	
	if number_of:
		number_of[0] = fac

	return p

def get_pair_combinations (n, s, m1, m2):

	cdef int *p, np, i, j
	p = generate_pair_combinations(n, s, m1, m2, &np)
	return [[p[(i * n) + j] for j in range(n)] for i in range(np)]


previous_equal_pair_combinations = {}

cdef int *generate_equal_pair_combinations(int n, int s, int m, int *number_of):

	cdef int *p, fac, i, j, smallest

	# see if we've already generated it!
	key = (n, s, m)
	if key in previous_equal_pair_combinations.iterkeys():
	
		cib = <combinatorial_info_block>previous_equal_pair_combinations[key]
		fac = cib.np
		p = cib.p
	
	else:
	
		fac = falling_factorial(n, s) * binomial(n - s, m - s) * binomial(n - m, m - s) / 2
		p = <int *> malloc (sizeof(int) * n * fac)
		i = 0
		vertices = range(1, n + 1)
		perms = Permutations(vertices, s)
		for perm in perms:
			available_verts = [v for v in vertices if not v in perm]
			combs1 = Combinations(available_verts, m - s)
			first_one = True
			for comb1 in combs1:
				remaining_verts = [v for v in available_verts if not v in comb1]
				combs2 = Combinations(remaining_verts, m - s)
				smallest = min(comb1)
				first_two = True
				for comb2 in combs2:
					if min(comb2) < smallest:
						continue
					for j in range(s):
						if first_one:
							p[(i * n) + j] = <int> perm[j]
						else:
							p[(i * n) + j] = <int> 0
					for j in range(m - s):
						if first_two:
							p[(i * n) + s + j] = <int> comb1[j]
						else:
							p[(i * n) + s + j] = <int> 0
					for j in range(m - s):
						p[(i * n) + m + j] = <int> comb2[j]
					for j in range(n - m - m + s):
						p[(i * n) + m + m - s + j] = <int> 0
					first_one = False
					first_two = False
					i += 1			

		cib = combinatorial_info_block()
		cib.np = fac
		cib.p = p
		previous_equal_pair_combinations[key] = cib
	
	if number_of:
		number_of[0] = fac

	return p

def get_equal_pair_combinations (n, s, m):

	cdef int *p, np, i, j
	p = generate_equal_pair_combinations(n, s, m, &np)
	return [[p[(i * n) + j] for j in range(n)] for i in range(np)]


cdef void raw_minimize_edges(int *edges, int m):

	cdef int i, *e

	for i in range(m):
		e = &edges[i * 3]
		if e[0] > e[1]:
			e[0], e[1] = e[1], e[0]
		if e[1] > e[2]:
			e[1], e[2] = e[2], e[1]
		if e[0] > e[1]:
			e[0], e[1] = e[1], e[0]

	cdef int round = 1, swapped
	
	while True:
	
		swapped = 0
		for i in range(m - round):
			
			e = &edges[i * 3]
			
			if e[0] < e[3]:
				continue
			if e[0] == e[3]:
				if e[1] < e[4]:
					continue
				if e[1] == e[4]:
					if e[2] < e[5]:
						continue
						
			e[0], e[3] = e[3], e[0]
			e[1], e[4] = e[4], e[1]
			e[2], e[5] = e[5], e[2]

			swapped = 1
			
		if swapped == 0:
			break
			
		round += 1

# TODO: make handle degenerate edges

def minimal_isomorph (g, tg):

	cdef int i, n, m, *edges, *new_edges, *e
	cdef int *p, np, is_lower
	
	n = g[0]
	m = len(g[1])
	if tg:
		t = tg[0]
	else:
		t = 0

	edges = <int *> malloc (sizeof(int) * 3 * m)
	new_edges = <int *> malloc (sizeof(int) * 3 * m)
	winning_edges = <int *> malloc (sizeof(int) * 3 * m)
	
	for i in range(m):
		e = &edges[3 * i]
		e[0] = g[1][i][0]
		e[1] = g[1][i][1]
		e[2] = g[1][i][2]
	
	p = generate_permutations_fixing(n, t, &np)

	for i in range(np):
	
		for j in range(3 * m):
			new_edges[j] = p[n * i + edges[j] - 1]
	
		raw_minimize_edges(new_edges, m)

		if i == 0:
			for j in range(3 * m):
				winning_edges[j] = new_edges[j]
			continue

		is_lower = 1

		for j in range(3 * m):
			if new_edges[j] > winning_edges[j]:
				is_lower = 0
				break
			elif new_edges[j] < winning_edges[j]:
				break
		
		if is_lower: # We have a new winner
			for j in range(3 * m):
				winning_edges[j] = new_edges[j]
	
	edge_list = []
	for i in range(0, 3 * m, 3):
		edge_list.append((winning_edges[i], winning_edges[i + 1], winning_edges[i + 2]))
	
	free(edges)
	free(new_edges)
	free(winning_edges)

	return (n, tuple(edge_list))


cdef void c_induced_subgraph (int *edges, int *new_edges, int m, int *new_m, int *verts, int s):

	cdef int nm = 0, i, j, k, *e, got, te[3]
	
	for i in range(m):
		e = &edges[3 * i]
		got = 0
		for j in range(s):
			if e[0] == verts[j]:
				got += 1
				te[0] = j + 1
			elif e[1] == verts[j]:
				got += 1
				te[1] = j + 1
			elif e[2] == verts[j]:
				got += 1
				te[2] = j + 1
		if got == 3:
			e = &new_edges[3 * nm]
			e[0] = te[0]
			e[1] = te[1]
			e[2] = te[2]
			nm += 1

	raw_minimize_edges(new_edges, nm)	
	new_m[0] = nm

	return


cdef void c_minimal_isomorph (int n, int *edges, int m, int t):

	cdef int i, *new_edges, *winning_edges, *e
	cdef int *p, np, is_lower
	
	new_edges = <int *> malloc (sizeof(int) * 3 * m)
	winning_edges = <int *> malloc (sizeof(int) * 3 * m)
	
	p = generate_permutations_fixing(n, t, &np)

	for i in range(np):
	
		for j in range(3 * m):
			new_edges[j] = p[n * i + edges[j] - 1]
	
		raw_minimize_edges(new_edges, m)

		if i == 0:
			for j in range(3 * m):
				winning_edges[j] = new_edges[j]
			continue

		is_lower = 1

		for j in range(3 * m):
			if new_edges[j] > winning_edges[j]:
				is_lower = 0
				break
			elif new_edges[j] < winning_edges[j]:
				break
		
		if is_lower: # We have a new winner
			for j in range(3 * m):
				winning_edges[j] = new_edges[j]
	
	for i in range(3 * m):
		edges[i] = winning_edges[i]
	
	free(new_edges)
	free(winning_edges)

	return


cdef int c_is_subgraph (int n, int *edges, int ne, int *edges_sub, int ne_sub):

	cdef int i, j, k, l, *p, np, *new_edges, got_all, got_edge, got

	new_edges = <int *> malloc (sizeof(int) * 3 * ne)
	
	p = generate_permutations(n, &np)

	for i in range(np):
	
		for j in range(3 * ne):
			new_edges[j] = p[n * i + edges[j] - 1]

		got_all = 1
		for j in range(ne_sub):
			got_edge = 0
			for k in range(ne):
				got = 0
				for l in range(3):
					if (edges_sub[3 * j] == new_edges[(3 * k) + l] or 
						edges_sub[(3 * j) + 1] == new_edges[(3 * k) + l] or
						edges_sub[(3 * j) + 2] == new_edges[(3 * k) + l]):
						got += 1
				if got == 3:
					got_edge = 1
					break
			if got_edge == 0:
				got_all = 0
				break
	
		if got_all:
			free(new_edges)
			return 1

	free(new_edges)
	return 0


#
# TODO: Make this function accept more than one type on s vertices.
#

def flag_products (graph_block gb, graph_block tb, graph_block flags1, graph_block flags2):

	cdef int *p, np, *pp, *pf1, *pf2, *edges, *cur_edges
	cdef int n, s, m1, m2, ne, i, j, k, gi
	cdef int cnte, cnf1e, cnf2e
	cdef int has_type, has_f1
	cdef int f1index, f2index, *grb, equal_flags_mode
		
	results = []
	
	sig_on()
	
	n = gb.n
	s = tb.n
	m1 = flags1.n

	if flags2:

		equal_flags_mode = 0
		m2 = flags2.n
		p = generate_pair_combinations(n, s, m1, m2, &np)

	else:

		equal_flags_mode = 1
		m2 = flags1.n
		flags2 = flags1
		p = generate_equal_pair_combinations(n, s, m1, &np)

	cur_edges = <int *> malloc (sizeof(int) * 3 * MAX_NUMBER_OF_EDGES)
	pf1 = <int *> malloc (sizeof(int) * m1)
	pf2 = <int *> malloc (sizeof(int) * m2)
	grb = <int *> malloc (flags1.len * flags2.len * sizeof(int))

	for gi in range(gb.len):

		sig_on()
	
		memset(grb, 0, flags1.len * flags2.len * sizeof(int))
	
		ne = gb.graphs[gi].ne
		edges = gb.graphs[gi].edges

		has_type = 0
		has_f1 = 0

		for i in range(np):
		
			pp = &p[(i * n)]
		
			if pp[0] != 0:
		
				for j in range(s):
					pf1[j] = pp[j]
					pf2[j] = pp[j]
			
				has_type = 0
				c_induced_subgraph(edges, cur_edges, ne, &cnte, pf1, s)
				
				if cnte == tb.graphs[0].ne:
					if all(cur_edges[j] == tb.graphs[0].edges[j] for j in range(cnte * 3)):
						has_type = 1
	
			if has_type == 0:
				continue
			
			if has_type and pp[s] != 0:
	
				has_f1 = 0
	
				for j in range(m1 - s):
					pf1[s + j] = pp[s + j]
	
				c_induced_subgraph(edges, cur_edges, ne, &cnf1e, pf1, m1)
				c_minimal_isomorph(n, cur_edges, cnf1e, s)
				
				for j in range(flags1.len):
					if flags1.graphs[j].ne == cnf1e:
						if all(cur_edges[k] == flags1.graphs[j].edges[k] for k in range(cnf1e * 3)):
							has_f1 = 1
							f1index = j
							break
	
			if has_f1 == 0:
				continue
	
			for j in range(m2 - s):
				pf2[s + j] = pp[m1 + j]
	
			c_induced_subgraph(edges, cur_edges, ne, &cnf2e, pf2, m2)
			c_minimal_isomorph(n, cur_edges, cnf2e, s)
			
			for j in range(flags2.len):
				if flags2.graphs[j].ne == cnf2e:
					if all(cur_edges[k] == flags2.graphs[j].edges[k] for k in range(cnf2e * 3)):
						f2index = j
						grb[(f1index * flags1.len) + f2index] += 1
						break

		sig_off()

		#
		# TODO: Maybe get this into pure C somehow.
		#

		resarray = matrix(QQ, flags1.len, flags2.len, sparse=True)

		if equal_flags_mode:
		
			npd = Integer(np * 2)
			for i in range(flags1.len):
				for j in range(i, flags1.len):
					k = grb[(i * flags1.len) + j] + grb[(j * flags1.len) + i]
					if k != 0:
						resarray[i, j] = k / npd
						resarray[j, i] = resarray[i, j]
		else:
		
			npd = Integer(np)
			for i in range(flags1.len):
				for j in range(flags2.len):
					k = grb[(i * flags1.len) + j]
					if k != 0:
						resarray[i, j] = k / npd		
		
		results.append(resarray)

	free(cur_edges)
	free(pf1)
	free(pf2)
	free(grb)
	
	return results


def has_forbidden_edge_numbers(g, forbidden_edge_numbers, must_have_highest=False):

	cdef int *c, nc, i, j, k, l, n, fe, *edges, *e, got, *comb, num_e, mhh

	n = g[0]
	m = len(g[1])
	edges = <int *> malloc (sizeof(int) * 3 * m)
	
	for i in range(m):
		e = &edges[3 * i]
		e[0] = g[1][i][0]
		e[1] = g[1][i][1]
		e[2] = g[1][i][2]

	for pk, pfe in forbidden_edge_numbers.iteritems():

		k = <int> pk
		fe = <int> pfe
		
		if k > n:
			continue # vacuous condition

		if fe < 1:
			raise ValueError
		
		if must_have_highest:
		
			c = generate_combinations(n - 1, k - 1, &nc)

			for i in range(nc):
				comb = &c[(k - 1) * i]
				num_e = 0
				for j in range(m):
					got = 0
					e = &edges[3 * j]
					for l in range(k - 1):
						if comb[l] == e[0] or comb[l] == e[1] or comb[l] == e[2]:
							got += 1
					if n == e[0] or n == e[1] or n == e[2]:
							got += 1
					if got == 3:
						num_e += 1
						if num_e == fe:
							free(edges)
							return True

		else:

			c = generate_combinations(n, k, &nc)

			for i in range(nc):
				comb = &c[k * i]
				num_e = 0
				for j in range(m):
					got = 0
					e = &edges[3 * j]
					for l in range(k):
						if comb[l] == e[0] or comb[l] == e[1] or comb[l] == e[2]:
							got += 1
					if got == 3:
						num_e += 1
						if num_e == fe:
							free(edges)
							return True

	free(edges)
	return False


def has_forbidden_graphs(g, graph_block forbidden_gb, must_have_highest=False, induced=False):

	cdef int *c, nc, i, j, k, n, fn, ne, cne, fne, *edges, *cur_edges, *e
	
	n = g[0]
	ne = len(g[1])
	edges = <int *> malloc (sizeof(int) * 3 * ne)
	cur_edges = <int *> malloc (sizeof(int) * 3 * ne)
	
	for i in range(ne):
		e = &edges[3 * i]
		e[0] = g[1][i][0]
		e[1] = g[1][i][1]
		e[2] = g[1][i][2]

	for i in range(forbidden_gb.len):

		fn = forbidden_gb.graphs[i].n
		fne = forbidden_gb.graphs[i].ne
		
		if fn > n:
			continue # vacuous condition

		if must_have_highest:
			c = generate_combinations_plus(n, fn, &nc)
		else:
			c = generate_combinations(n, fn, &nc)

		for j in range(nc):
		
			c_induced_subgraph(edges, cur_edges, ne, &cne, &c[j * fn], fn)
			
			if cne < forbidden_gb.graphs[i].ne:
				continue
				
			if induced and cne > forbidden_gb.graphs[i].ne:
				continue
			
			if c_is_subgraph(fn, cur_edges, cne, forbidden_gb.graphs[i].edges, forbidden_gb.graphs[i].ne):
				free(edges)
				free(cur_edges)
				return True

	free(edges)
	free(cur_edges)
	return False
	